{"version":3,"file":"replay.min.js","sources":["../src/replay.js"],"sourcesContent":["export default class Replay {\n    constructor(elementId, filePath, speed = 1, loop = false, controllerId) {\n        console.log(filePath,elementId,controllerId);\n        this.replayInProgress = false;\n        this.speed = speed;\n        this.loop = loop;\n        const element = document.getElementById(elementId);\n        if (element) {\n            this.outputElement = element;\n        } else {\n            throw new Error(`Element with id '${elementId}' not found`);\n        }\n        if (controllerId) {\n            console.log(\"made it here\");\n            this.constructController(controllerId);\n        }\n        this.loadJSON(filePath)\n            .then((data) => {\n                this.logData = data;\n                // support for Cursive Recorder extension files (and outdated Curisve file formats)\n                // logData should be a list of dictionaries for this to work properly\n                if (\"data\" in this.logData) {\n                    this.logData = this.logData['data'];\n                }\n                ;\n                if (\"payload\" in this.logData) {\n                    this.logData = this.logData['payload'];\n                }\n                ;\n                this.startReplay();\n            })\n            .catch(error => {\n                throw new Error('Error loading JSON file: ' + error.message);\n            });\n    }\n\n    constructController(controllerId) {\n        const controller = document.getElementById(controllerId);\n        console.log(controller);\n        if (controller) {\n            // this.buttonElement = document.createElement('button');\n            // this.buttonElement.id = 'playerButton';\n            // this.buttonElement.textContent = 'Play';\n            this.scrubberElement = document.createElement('input');\n            this.scrubberElement.type = 'range';\n            this.scrubberElement.id = 'timelineScrubber';\n            this.scrubberElement.min = '0';\n            this.scrubberElement.max = '100';\n            this.scrubberElement.addEventListener('input', () => {\n                const scrubberValue = this.scrubberElement.value;\n                this.skipToTime(scrubberValue);\n            });\n            controller.appendChild(this.scrubberElement);\n        }\n    }\n\n    setScrubberVal(value) {\n        if (this.scrubberElement) {\n            this.scrubberElement.value = String(value);\n        }\n    }\n\n    loadJSON(filePath) {\n        return fetch(filePath)\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error('Failed to fetch JSON file');\n                }\n                if (response.headers.get('content-length') === '0') {\n                    throw new Error('Empty JSON response');\n                }\n                let response_json = response.json();\n                return response_json;\n            })\n            .catch(error => {\n                throw new Error('Error loading JSON file: ' + error.message);\n            });\n    }\n\n    // call this to make a \"start\" or \"start over\" function\n    startReplay() {\n        // clear previous instances of timeout to prevent multiple running at once\n        if (this.replayInProgress) {\n            clearTimeout(this.replayTimeout);\n        };\n        this.replayInProgress = true;\n        this.outputElement.innerHTML = '';\n        this.replayLog();\n    }\n\n    // called by startReplay() to recursively call through keydown events\n    replayLog() {\n        let textOutput = \"\";\n        let index = 0;\n        const processEvent = () => {\n            console.log(11);\n            if (this.replayInProgress) {\n                if (index < this.logData.length) {\n                    let event = this.logData[index++];\n                    if (event.event.toLowerCase() === 'keydown') { // can sometimes be keydown or keyDown\n                        textOutput = this.applyKey(event.key, textOutput);\n                    }\n                    this.outputElement.innerHTML = textOutput;\n                    this.setScrubberVal(index / this.logData.length * 100);\n                    this.replayTimeout = setTimeout(processEvent, 1 / this.speed * 100);\n                } else {\n                    this.replayInProgress = false;\n                    if (this.loop) {\n                        this.startReplay();\n                    }\n                    ;\n                }\n            }\n        };\n        processEvent();\n    }\n\n    skipToEnd() {\n        if (this.replayInProgress) {\n            this.replayInProgress = false;\n        }\n        let textOutput = \"\";\n        this.logData.forEach(event => {\n            if (event.event.toLowerCase() === 'keydown') {\n                textOutput = this.applyKey(event.key, textOutput);\n            }\n        });\n        this.outputElement.innerHTML = textOutput.slice(0, -1);\n        this.setScrubberVal(100);\n    }\n\n    // used by the scrubber to skip to a certain percentage of data\n    skipToTime(percentage) {\n        if (this.replayInProgress) {\n            this.replayInProgress = false;\n        }\n        // only go through certain % of log data\n        let textOutput = \"\";\n        const numElementsToProcess = Math.ceil(this.logData.length * percentage / 100);\n        for (let i = 0; i < numElementsToProcess; i++) {\n            const event = this.logData[i];\n            if (event.event.toLowerCase() === 'keydown') {\n                textOutput = this.applyKey(event.key, textOutput);\n            }\n        }\n        this.outputElement.innerHTML = textOutput.slice(0, -1);\n        this.setScrubberVal(percentage);\n    }\n\n    // used in various places to add a keydown, backspace, etc. to the output\n    applyKey(key, textOutput) {\n        switch (key) {\n            case \"Enter\":\n                return textOutput + \"\\n\";\n            case \"Backspace\":\n                return textOutput.slice(0, -1);\n            case \"ControlBackspace\":\n                let lastSpace = textOutput.lastIndexOf(' ');\n                return textOutput.slice(0, lastSpace);\n            default:\n                return ![\"Shift\", \"Ctrl\", \"Alt\", \"ArrowDown\", \"ArrowUp\", \"Control\", \"ArrowRight\", \"ArrowLeft\"].includes(key) ? textOutput + key : textOutput;\n        }\n    }\n}\n"],"names":["constructor","elementId","filePath","speed","loop","controllerId","console","log","replayInProgress","element","document","getElementById","Error","outputElement","constructController","loadJSON","then","data","logData","this","startReplay","catch","error","message","controller","scrubberElement","createElement","type","id","min","max","addEventListener","scrubberValue","value","skipToTime","appendChild","setScrubberVal","String","fetch","response","ok","headers","get","json","clearTimeout","replayTimeout","innerHTML","replayLog","textOutput","index","processEvent","length","event","toLowerCase","applyKey","key","setTimeout","skipToEnd","forEach","slice","percentage","numElementsToProcess","Math","ceil","i","lastSpace","lastIndexOf","includes"],"mappings":"2KACIA,YAAYC,UAAWC,cAAUC,6DAAQ,EAAGC,6DAAcC,oDACtDC,QAAQC,IAAIL,SAASD,UAAUI,mBAC1BG,kBAAmB,OACnBL,MAAQA,WACRC,KAAOA,WACNK,QAAUC,SAASC,eAAeV,eACpCQ,cAGM,IAAIG,iCAA0BX,+BAF/BY,cAAgBJ,QAIrBJ,eACAC,QAAQC,IAAI,qBACPO,oBAAoBT,oBAExBU,SAASb,UACTc,MAAMC,YACEC,QAAUD,KAGX,SAAUE,KAAKD,eACVA,QAAUC,KAAKD,QAAL,MAGf,YAAaC,KAAKD,eACbA,QAAUC,KAAKD,QAAL,cAGdE,iBAERC,OAAMC,cACG,IAAIV,MAAM,4BAA8BU,MAAMC,YAIhET,oBAAoBT,oBACVmB,WAAad,SAASC,eAAeN,cAC3CC,QAAQC,IAAIiB,YACRA,kBAIKC,gBAAkBf,SAASgB,cAAc,cACzCD,gBAAgBE,KAAO,aACvBF,gBAAgBG,GAAK,wBACrBH,gBAAgBI,IAAM,SACtBJ,gBAAgBK,IAAM,WACtBL,gBAAgBM,iBAAiB,SAAS,WACrCC,cAAgBb,KAAKM,gBAAgBQ,WACtCC,WAAWF,kBAEpBR,WAAWW,YAAYhB,KAAKM,kBAIpCW,eAAeH,OACPd,KAAKM,uBACAA,gBAAgBQ,MAAQI,OAAOJ,QAI5ClB,SAASb,iBACEoC,MAAMpC,UACRc,MAAKuB,eACGA,SAASC,SACJ,IAAI5B,MAAM,gCAE2B,MAA3C2B,SAASE,QAAQC,IAAI,wBACf,IAAI9B,MAAM,8BAEA2B,SAASI,UAGhCtB,OAAMC,cACG,IAAIV,MAAM,4BAA8BU,MAAMC,YAKhEH,cAEQD,KAAKX,kBACLoC,aAAazB,KAAK0B,oBAEjBrC,kBAAmB,OACnBK,cAAciC,UAAY,QAC1BC,YAITA,gBACQC,WAAa,GACbC,MAAQ,QACNC,aAAe,QACjB5C,QAAQC,IAAI,IACRY,KAAKX,oBACDyC,MAAQ9B,KAAKD,QAAQiC,OAAQ,KACzBC,MAAQjC,KAAKD,QAAQ+B,SACS,YAA9BG,MAAMA,MAAMC,gBACZL,WAAa7B,KAAKmC,SAASF,MAAMG,IAAKP,kBAErCnC,cAAciC,UAAYE,gBAC1BZ,eAAea,MAAQ9B,KAAKD,QAAQiC,OAAS,UAC7CN,cAAgBW,WAAWN,aAAc,EAAI/B,KAAKhB,MAAQ,eAE1DK,kBAAmB,EACpBW,KAAKf,WACAgB,eAMrB8B,eAGJO,YACQtC,KAAKX,wBACAA,kBAAmB,OAExBwC,WAAa,QACZ9B,QAAQwC,SAAQN,QACiB,YAA9BA,MAAMA,MAAMC,gBACZL,WAAa7B,KAAKmC,SAASF,MAAMG,IAAKP,qBAGzCnC,cAAciC,UAAYE,WAAWW,MAAM,GAAI,QAC/CvB,eAAe,KAIxBF,WAAW0B,YACHzC,KAAKX,wBACAA,kBAAmB,OAGxBwC,WAAa,SACXa,qBAAuBC,KAAKC,KAAK5C,KAAKD,QAAQiC,OAASS,WAAa,SACrE,IAAII,EAAI,EAAGA,EAAIH,qBAAsBG,IAAK,OACrCZ,MAAQjC,KAAKD,QAAQ8C,GACO,YAA9BZ,MAAMA,MAAMC,gBACZL,WAAa7B,KAAKmC,SAASF,MAAMG,IAAKP,kBAGzCnC,cAAciC,UAAYE,WAAWW,MAAM,GAAI,QAC/CvB,eAAewB,YAIxBN,SAASC,IAAKP,mBACFO,SACC,eACMP,WAAa,SACnB,mBACMA,WAAWW,MAAM,GAAI,OAC3B,uBACGM,UAAYjB,WAAWkB,YAAY,YAChClB,WAAWW,MAAM,EAAGM,yBAEnB,CAAC,QAAS,OAAQ,MAAO,YAAa,UAAW,UAAW,aAAc,aAAaE,SAASZ,KAA0BP,WAAnBA,WAAaO"}